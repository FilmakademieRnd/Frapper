/*
-----------------------------------------------------------------------------
This source file is part of FRAPPER
research.animationsinstitut.de
sourceforge.net/projects/frapper

Copyright (c) 2008-2014 Filmakademie Baden-Wuerttemberg, Institute of Animation 

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free Software
Foundation; version 2.1 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place - Suite 330, Boston, MA 02111-1307, USA, or go to
http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
-----------------------------------------------------------------------------
*/

/////////////////////////////////////////////////
///////////inputs
// The gradients are the midpoints of the vertices of a cube.
static int3 grad3[12] = {
    {1,1,0}, {-1,1,0}, {1,-1,0}, {-1,-1,0},
    {1,0,1}, {-1,0,1}, {1,0,-1}, {-1,0,-1},
    {0,1,1}, {0,-1,1}, {0,1,-1}, {0,-1,-1}
};

// The gradients are the midpoints of the vertices of a hypercube.
static int4 grad4[32] = {
    {0,1,1,1},  {0,1,1,-1},  {0,1,-1,1},  {0,1,-1,-1},
    {0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},
    {1,0,1,1},  {1,0,1,-1},  {1,0,-1,1},  {1,0,-1,-1},
    {-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},
    {1,1,0,1},  {1,1,0,-1},  {1,-1,0,1},  {1,-1,0,-1},
    {-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},
    {1,1,1,0},  {1,1,-1,0},  {1,-1,1,0},  {1,-1,-1,0},
    {-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}
};

// A lookup table to traverse the simplex around a given point in 4D.
static  int4 simplex[64] = {
    {0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},
    {0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},
    {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
    {1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},
    {1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},
    {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
    {2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},
    {2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}
};

cbuffer inputBuffer : register(b[0]) {
	//int permA[512];
	//int permR[512];
	//int permG[512];
	//int permB[512];
	int seed;
	int count;
	float frequency, lacunarity, gain, offset, offsetX, offsetY;
	int dimensionsOut;
	int process;
}

static int octaves = 1;

static uint permA[512] = {
    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
    134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
    55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,
    18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
    250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
    189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
    172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
    228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
    107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,

    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
    134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
    55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,
    18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
    250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
    189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
    172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
    228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
    107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
};

static uint permR[512] = {
    78,49,46,204,79,129,194,106,144,93,16,56,81,209,188,149,251,
	103,19,114,23,121,132,200,171,210,127,44,169,30,67,243,76,184,
	205,214,7,221,85,139,99,255,225,105,222,9,24,233,20,40,138,238,
	74,215,130,231,137,250,70,2,155,217,31,157,102,71,12,211,133,154,
	28,165,15,239,34,248,110,203,230,170,187,53,58,178,252,142,160,
	193,168,199,240,75,14,25,186,109,245,235,80,140,244,63,156,247,
	212,89,181,115,54,167,72,45,88,18,47,55,66,116,196,26,21,141,
	39,159,175,77,82,29,134,122,62,216,1,234,73,41,37,64,83,136,
	143,11,8,131,97,108,35,0,180,92,177,226,227,91,120,104,101,57,
	13,112,219,147,118,52,241,36,61,185,189,218,253,249,183,146,246,
	152,179,27,6,10,68,202,172,237,50,22,207,223,162,96,190,3,38,
	228,201,125,148,161,192,213,123,111,220,69,87,32,43,208,98,42,
	197,5,119,90,191,17,135,163,198,51,182,254,107,166,33,59,150,
	145,176,48,126,86,124,232,113,100,224,206,174,242,164,195,65,
	236,117,229,94,84,173,60,4,153,151,158,128,95,

	78,49,46,204,79,129,194,106,144,93,16,56,81,209,188,149,251,
	103,19,114,23,121,132,200,171,210,127,44,169,30,67,243,76,184,
	205,214,7,221,85,139,99,255,225,105,222,9,24,233,20,40,138,238,
	74,215,130,231,137,250,70,2,155,217,31,157,102,71,12,211,133,154,
	28,165,15,239,34,248,110,203,230,170,187,53,58,178,252,142,160,
	193,168,199,240,75,14,25,186,109,245,235,80,140,244,63,156,247,
	212,89,181,115,54,167,72,45,88,18,47,55,66,116,196,26,21,141,
	39,159,175,77,82,29,134,122,62,216,1,234,73,41,37,64,83,136,
	143,11,8,131,97,108,35,0,180,92,177,226,227,91,120,104,101,57,
	13,112,219,147,118,52,241,36,61,185,189,218,253,249,183,146,246,
	152,179,27,6,10,68,202,172,237,50,22,207,223,162,96,190,3,38,
	228,201,125,148,161,192,213,123,111,220,69,87,32,43,208,98,42,
	197,5,119,90,191,17,135,163,198,51,182,254,107,166,33,59,150,
	145,176,48,126,86,124,232,113,100,224,206,174,242,164,195,65,
	236,117,229,94,84,173,60,4,153,151,158,128,95
};

static uint permG[512] = {
    1,20,146,105,72,39,15,144,173,228,38,130,81,206,221,198,149,217,111,151,25,88,2,79,
	10,177,185,195,155,140,147,53,226,167,32,95,90,125,67,78,71,129,40,99,61,204,133,213,
	49,138,254,30,244,118,224,120,250,134,150,87,157,58,192,176,100,178,183,48,240,126,
	102,148,75,235,114,101,37,142,65,116,227,179,55,215,136,16,245,223,222,135,209,188,
	218,13,252,229,207,166,172,83,186,121,6,5,199,45,230,33,171,93,238,80,161,82,108,119,
	110,197,29,131,50,196,60,63,27,251,8,216,57,255,200,132,117,11,137,113,220,14,52,211,
	189,77,174,231,94,208,168,187,248,46,145,249,247,184,18,239,194,41,236,181,225,28,127,
	165,44,234,241,210,128,84,112,246,42,253,91,59,35,124,68,237,89,64,74,21,232,24,69,9,
	86,51,7,158,233,4,143,96,170,169,56,98,139,191,62,36,97,190,3,201,219,43,163,106,212,
	162,193,242,47,26,107,85,202,141,160,205,175,156,182,19,0,154,70,153,76,103,23,115,203,
	73,243,164,92,17,34,214,104,152,54,109,159,123,122,66,180,31,22,12,

	 1,20,146,105,72,39,15,144,173,228,38,130,81,206,221,198,149,217,111,151,25,88,2,79,
	10,177,185,195,155,140,147,53,226,167,32,95,90,125,67,78,71,129,40,99,61,204,133,213,
	49,138,254,30,244,118,224,120,250,134,150,87,157,58,192,176,100,178,183,48,240,126,
	102,148,75,235,114,101,37,142,65,116,227,179,55,215,136,16,245,223,222,135,209,188,
	218,13,252,229,207,166,172,83,186,121,6,5,199,45,230,33,171,93,238,80,161,82,108,119,
	110,197,29,131,50,196,60,63,27,251,8,216,57,255,200,132,117,11,137,113,220,14,52,211,
	189,77,174,231,94,208,168,187,248,46,145,249,247,184,18,239,194,41,236,181,225,28,127,
	165,44,234,241,210,128,84,112,246,42,253,91,59,35,124,68,237,89,64,74,21,232,24,69,9,
	86,51,7,158,233,4,143,96,170,169,56,98,139,191,62,36,97,190,3,201,219,43,163,106,212,
	162,193,242,47,26,107,85,202,141,160,205,175,156,182,19,0,154,70,153,76,103,23,115,203,
	73,243,164,92,17,34,214,104,152,54,109,159,123,122,66,180,31,22,12
};

static uint permB[512] = {
    96,175,42,11,92,138,143,224,61,142,73,251,127,98,182,38,50,215,172,190,239,87,108,246,
	184,176,31,65,148,206,169,120,113,112,228,76,23,162,198,177,211,234,54,200,233,104,218,
	75,94,128,130,247,196,243,191,223,52,126,167,36,164,156,68,72,70,249,43,248,165,84,245,
	41,226,83,22,66,49,93,217,137,21,131,216,63,222,161,140,146,136,20,30,133,135,155,141,
	241,12,189,116,199,6,82,152,51,242,153,25,160,101,235,16,91,9,197,145,77,232,195,14,231,
	194,44,13,147,4,59,114,56,171,78,1,238,86,151,27,80,230,214,212,5,110,192,173,193,60,
	144,67,18,39,237,213,125,201,219,79,254,29,163,33,95,115,124,89,186,157,139,102,81,132,
	208,221,47,2,205,178,34,170,46,7,166,185,159,71,252,122,53,154,181,69,0,209,28,117,158,
	17,253,74,35,244,210,64,207,187,149,109,188,107,57,32,3,15,180,40,134,150,97,250,236,58,
	45,225,111,174,10,129,106,48,88,202,203,240,119,227,179,105,99,255,183,85,220,168,24,26,
	229,37,8,121,103,204,123,62,100,19,118,90,55,

	96,175,42,11,92,138,143,224,61,142,73,251,127,98,182,38,50,215,172,190,239,87,108,246,
	184,176,31,65,148,206,169,120,113,112,228,76,23,162,198,177,211,234,54,200,233,104,218,
	75,94,128,130,247,196,243,191,223,52,126,167,36,164,156,68,72,70,249,43,248,165,84,245,
	41,226,83,22,66,49,93,217,137,21,131,216,63,222,161,140,146,136,20,30,133,135,155,141,
	241,12,189,116,199,6,82,152,51,242,153,25,160,101,235,16,91,9,197,145,77,232,195,14,231,
	194,44,13,147,4,59,114,56,171,78,1,238,86,151,27,80,230,214,212,5,110,192,173,193,60,
	144,67,18,39,237,213,125,201,219,79,254,29,163,33,95,115,124,89,186,157,139,102,81,132,
	208,221,47,2,205,178,34,170,46,7,166,185,159,71,252,122,53,154,181,69,0,209,28,117,158,
	17,253,74,35,244,210,64,207,187,149,109,188,107,57,32,3,15,180,40,134,150,97,250,236,58,
	45,225,111,174,10,129,106,48,88,202,203,240,119,227,179,105,99,255,183,85,220,168,24,26,
	229,37,8,121,103,204,123,62,100,19,118,90,55
};

/////////////////////////////////////////////////////
/////structs

struct A2V {
	float4 pos	:POSITION;
};

struct V2G {
	float4 pos	:POSITION;
};

struct G2P {
	float4 pos	:SV_POSITION;
};

struct P2F{
	float4 col	:SV_TARGET;
};

static  float ViewportRes = 512;

/////////////////////////////////////////////////////
//functions new (simplex)

float ndot( int3 g, float x, float y) { return g[0]*x + g[1]*y; }
float ndot( int3 g, float x,  float y,  float z ) { return g[0]*x + g[1]*y + g[2]*z; }
float ndot( int4 g, float x,  float y,  float z,  float w ) { return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }

uint getPermA(uint id){
	
	uint p = permA[id];
	p = p^(seed&255);
	for (int i=0;i<octaves-1;i++){p=permA[p];}
	return p;
}

uint getPermR(uint id){
	
	uint p = permR[id];
	p = p^(seed&255);
	for (int i=0;i<octaves-1;i++){p=permR[p];}
	return p;
}

uint getPermG(uint id){
	
	uint p = permG[id];
	p = p^(seed&255);
	for (int i=0;i<octaves-1;i++){p=permG[p];}
	return p;
}

uint getPermB(uint id){
	
	uint p = permB[id];
	p = p^(seed&255);
	for (int i=0;i<octaves-1;i++){p=permB[p];}
	return p;
}

// 2D raw Simplex noise
float4 snoise( float2 p) {
    // Noise contributions from the three corners
	
	float3 nR  = float3(0.0,0.0,0.0);
	float3 nG  = float3(0.0,0.0,0.0);
	float3 nB  = float3(0.0,0.0,0.0);
	
	float3 nA  = float3(0.0,0.0,0.0);

    // Skew the input space to determine which simplex cell we're in
    float F2 = 0.36602540378; //0.5 * (sqrtf(3.0) - 1.0);
    // Hairy factor for 2D
    float s = (p.x + p.y) * F2;
	int2 i = floor(int2( p.x + s , p.y + s ));

    float G2 = 0.2113248654;//(3.0 - sqrtf(3.0)) / 6.0;
    float t = (i.x + i.y) * G2;
    // Unskew the cell origin back to (x,y) space
	float2 P0 = {i.x-t,i.y-t};
    // The x,y distances from the cell origin
	float2 p0 = {p.x-P0.x,p.y-P0.y};

    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
	int2 i1; // Offsets for second (middle) corner of simplex in (i,j) coords
	int stepOut = step(p0.x,p0.y); // lower triangle, XY order: (0,0)->(1,0)->(1,1) // upper triangle, YX order: (0,0)->(0,1)->(1,1)
	i1.x = 1-stepOut;
	i1.y = stepOut;

    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
	float2 p1 = {p0.x - i1.x + G2,p0.y - i1.y + G2}; // Offsets for middle corner in (x,y) unskewed coords
	float2 p2 = {p0.x - 1.0 + 2.0 * G2, p0.y - 1.0 + 2.0 * G2}; // Offsets for last corner in (x,y) unskewed coords

    // Work out the hashed gradient indices of the three simplex corners
	int2 ii = {i.x & 255,i.y & 255};
	//int iter = ii.y;
	//for (uint i=0;i<iteration;i++) iter = permR[iter];
	uint gRi0,gRi1,gRi2,
		gGi0,gGi1,gGi2,
		gBi0,gBi1,gBi2,
		gAi0,gAi1,gAi2;
    gAi0 = getPermA(ii.x+getPermA(ii.y)) % 12;
    gAi1 = getPermA(ii.x+i1.x+getPermA(ii.y+i1.y)) % 12;
    gAi2 = getPermA(ii.x+1+getPermA(ii.y+1)) % 12;
	
	//if(dimensionsOut>0){
		gRi0 = getPermR(ii.x+getPermR(ii.y)) % 12;
		gRi1 = getPermR(ii.x+i1.x+getPermR(ii.y+i1.y)) % 12;
		gRi2 = getPermR(ii.x+1+getPermR(ii.y+1)) % 12;
		//if(dimensionsOut>1){
			gGi0 = getPermG(ii.x+getPermG(ii.y)) % 12;
			gGi1 = getPermG(ii.x+i1.x+getPermG(ii.y+i1.y)) % 12;
			gGi2 = getPermG(ii.x+1+getPermG(ii.y+1)) % 12;
			//if(dimensionsOut>2){
				gBi0 = getPermB(ii.x+getPermB(ii.y)) % 12;
				gBi1 = getPermB(ii.x+i1.x+getPermB(ii.y+i1.y)) % 12;
				gBi2 = getPermB(ii.x+1+getPermB(ii.y+1)) % 12;
			//}
		//}
	//}
	//*/
    // Calculate the contribution from the three corners
    float t0 = 0.5 - p0.x*p0.x-p0.y*p0.y;
    if(t0<0) nA.x=nR.x=nG.x=nB.x = 0.0;
    else {
        t0 *= t0;
        nA.x = t0 * t0 * ndot(grad3[gAi0], p0.x, p0.y); // (x,y) of grad3 used for 2D gradient
		
		if(dimensionsOut>0){
			nR.x = t0 * t0 * ndot(grad3[gRi0], p0.x, p0.y);
			if(dimensionsOut>1){
				nG.x = t0 * t0 * ndot(grad3[gGi0], p0.x, p0.y);
				if(dimensionsOut>2){
					nB.x = t0 * t0 * ndot(grad3[gBi0], p0.x, p0.y);
				}
			}
		}
		
    }

    float t1 = 0.5 - p1.x*p1.x-p1.y*p1.y;
    if(t1<0) nA.y=nR.y=nG.y=nB.y = 0.0;
    else {
        t1 *= t1;
        nA.y = t1 * t1 * ndot(grad3[gAi1], p1.x, p1.y);
		
		if(dimensionsOut>0){
			nR.y = t1 * t1 * ndot(grad3[gRi1], p1.x, p1.y);
			if(dimensionsOut>1){
				nG.y = t1 * t1 * ndot(grad3[gGi1], p1.x, p1.y);
				if(dimensionsOut>2){
					nB.y = t1 * t1 * ndot(grad3[gBi1], p1.x, p1.y);
				}
			}
		}
		
    }

    float t2 = 0.5 - p2.x*p2.x-p2.y*p2.y;
    if(t2<0) nA.z=nR.z=nG.z=nB.z = 0.0;
    else {
        t2 *= t2;
        nA.z = t2 * t2 * ndot(grad3[gAi2], p2.x, p2.y);
		
		if(dimensionsOut>0){
			nR.z = t2 * t2 * ndot(grad3[gRi2], p2.x, p2.y);
			if(dimensionsOut>1){
				nG.z = t2 * t2 * ndot(grad3[gGi2], p2.x, p2.y);
				if(dimensionsOut>2){
					nB.z = t2 * t2 * ndot(grad3[gBi2], p2.x, p2.y);
				}
			}
		}
		
    }

    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70.0 * float4(	(nR.x + nR.y + nR.z),
							(nG.x + nG.y + nG.z),
							(nB.x + nB.y + nB.z),
							(nA.x + nA.y + nA.z)	);
}


/////////////////////////////////////////////////////
//functions on noise

// fractal sum, range -1.0 - 1.0
float4 fBm(float2 p)
{
	float freq = frequency, amp = 0.5;
	float4 sum = 0;	
	for(int i = 0; i < octaves; i++) 
	{
		//sum += pnoise(p * freq) * amp;
		sum += snoise(p * freq) * amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}
// fractal abs sum, range 0.0 - 1.0
float4 turbulence(float2 p)
{
	float4 sum = 0;
	float freq = frequency, amp = 1.0;
	for(int i = 0; i < octaves; i++) 
	{
		sum += abs(snoise(p*freq))*amp;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}
// Ridged multifractal, range 0.0 - 1.0
// See "Texturing & Modeling, A Procedural Approach", Chapter 12
float4 ridge(float4 h)
{
    h = abs(h);
    h = offset - h;
    h = h * h;
    return h;
}
float4 ridgedmf(float2 p)
{
	float4 sum = 0;
	float freq = frequency, amp = 0.5;
	float4 prev = float4(1.0,1.0,1.0,1.0);
	for(int i = 0; i < octaves; i++) 
	{
		float4 n = ridge(snoise(p*freq));
		sum += n*amp*prev;
		prev = n;
		freq *= lacunarity;
		amp *= gain;
	}
	return sum;
}

/////////////////////////////////////////////////////

void main_vs( 	in A2V In,
				out V2G Out	)
{
    Out.pos = In.pos;
}

/////////////////////////////////////////////////////
// creates a flat rectangle over the viewport, no need to change for flatshaders
// also here we calculate the random value array
[maxvertexcount(4)]
void main_gs(	line V2G In[2],
				inout TriangleStream<G2P> Out) {
	
	G2P vA,vB,vC,vD;

	vA.pos = float4( 1, 1, 0, 0);
	vB.pos = float4( 1,-1, 0, 0);
	vC.pos = float4(-1,-1, 0, 0);
	vD.pos = float4(-1, 1, 0, 0);
	Out.Append(vA);
	Out.Append(vB);
	Out.Append(vC);
	Out.Append(vD);
}
/////////////////////////////////////////////////////

void main_ps(	in G2P In,
				out P2F Out	)
{
	
	// set the output
	if(((In.pos.x-.5f)+(In.pos.y-.5f)*ViewportRes)<count){
		float2 p = ((float2)(In.pos.xy)+float2(offsetX,offsetY))/ViewportRes;
		float4 n = 0;
		if(process<=2) {
			n = fBm(p);
			if(process==1) n = abs(n);
			else if(process==2) n = (n+1)*.5;
		}
		else if(process==3) n = turbulence(p);
		else if(process==4) n = ridgedmf(p);
		
		Out.col = n;
	} else {
		Out.col = float4(0,0,0,0);
	}
	
	
	
}
